# CLAUDE.md - Gradio CRUD Application for Documents Management

## Project Overview

Build a local Gradio-based CRUD application for managing a PostgreSQL `documents` table. This application provides a simple UI for creating, reading, updating, and soft-deleting document records consisting of job descriptions, resumes, summaries, and names. The application supports <100 documents with search functionality by name.

## Technical Stack

- **Backend**: PostgreSQL 17
- **Frontend**: Gradio (latest stable version)
- **Database Driver**: psycopg2-binary
- **Environment Management**: python-dotenv
- **Package Manager**: uv
- **Code Style**: black
- **Deployment**: Local development only (single user)

## Architecture Overview

### Components

1. **Database Layer** (`db.py`): PostgreSQL connection and CRUD operations
2. **UI Layer** (`app.py`): Gradio interface with event handlers
3. **Configuration** (`.env`): Database credentials
4. **Migration** (`migrations/001_create_documents_table.sql`): Database schema

### Data Flow
```
User Input → Gradio UI → Database Operations → PostgreSQL
              ↓
    Search/Filter → Query Results → Display (truncated in table, full in form)
```

## File Structure
```
gradio-documents-crud/
├── .env.example          # Template for environment variables
├── .env                  # Actual credentials (gitignored)
├── .gitignore
├── README.md             # Setup and usage instructions
├── pyproject.toml        # uv project configuration
├── requirements.txt      # Generated by uv
├── migrations/
│   └── 001_create_documents_table.sql
├── src/
│   ├── __init__.py
│   ├── app.py           # Main Gradio application
│   └── db.py            # Database operations
└── tests/
    └── __init__.py
```

## Database Schema

### Migration File: `migrations/001_create_documents_table.sql`
```sql
-- Create the documents table
CREATE TABLE IF NOT EXISTS documents (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    resume TEXT,
    jd TEXT,
    summary TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP DEFAULT NULL
);

-- Add descriptions to the columns
COMMENT ON COLUMN documents.id IS 'Unique identifier for each document collection';
COMMENT ON COLUMN documents.name IS 'Name of the collection of documents (must be unique)';
COMMENT ON COLUMN documents.resume IS 'Resume storage (average 8192 characters)';
COMMENT ON COLUMN documents.jd IS 'The job description accompanying the resume (average 8192 characters)';
COMMENT ON COLUMN documents.summary IS 'A summary for this collection of documents';
COMMENT ON COLUMN documents.created_at IS 'Timestamp when record was created';
COMMENT ON COLUMN documents.updated_at IS 'Timestamp when record was last updated';
COMMENT ON COLUMN documents.deleted_at IS 'Timestamp when record was soft-deleted (NULL if active)';

-- Create index on name for faster lookups and uniqueness
CREATE INDEX IF NOT EXISTS idx_documents_name ON documents(name);

-- Create partial index for active (non-deleted) documents
CREATE INDEX IF NOT EXISTS idx_documents_active ON documents(deleted_at) WHERE deleted_at IS NULL;

-- Create trigger to auto-update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_documents_updated_at
    BEFORE UPDATE ON documents
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

## Environment Configuration

### `.env.example`
```env
# PostgreSQL Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_NAME=documents_db
DB_USER=your_username
DB_PASSWORD=your_password

# Optional: Connection string format (alternative to individual variables)
# DATABASE_URL=postgresql://user:password@localhost:5432/documents_db
```

## Database Module (`src/db.py`)

### Requirements

- Connection pooling for efficiency
- Parameterized queries to prevent SQL injection
- Proper error handling with informative messages
- Transaction management for data integrity
- Connection context managers
- Soft delete implementation (set deleted_at timestamp)
- Filter active records (WHERE deleted_at IS NULL)

### Key Functions
```python
def get_connection() -> psycopg2.extensions.connection:
    """Establish database connection using environment variables."""

def initialize_database() -> bool:
    """Run migration and verify database is ready."""

def get_all_documents(search_name: str = "") -> List[Tuple]:
    """
    Retrieve all active (non-deleted) documents.
    If search_name provided, filter by name (case-insensitive ILIKE).
    Order by updated_at DESC.
    Returns tuple: (id, name, resume, jd, summary, created_at, updated_at)
    """

def get_document_by_id(doc_id: int) -> Optional[Tuple]:
    """Retrieve a single active document by ID."""

def create_document(name: str, resume: str, jd: str, summary: str) -> Tuple[bool, str, Optional[int]]:
    """
    Insert new document and return (success, message, id).
    Handle UNIQUE constraint violation on name.
    Returns:
        - (True, "Success message", doc_id) on success
        - (False, "Error message", None) on failure
    """

def update_document(doc_id: int, name: str, resume: str, jd: str, summary: str) -> Tuple[bool, str]:
    """
    Update existing active document.
    Handle UNIQUE constraint violation if name conflicts with another document.
    Returns:
        - (True, "Success message") on success
        - (False, "Error message") on failure
    """

def soft_delete_document(doc_id: int) -> Tuple[bool, str]:
    """
    Soft delete document by setting deleted_at to CURRENT_TIMESTAMP.
    Only affects active documents (deleted_at IS NULL).
    Returns:
        - (True, "Success message") on success
        - (False, "Error message") on failure
    """

def check_name_exists(name: str, exclude_id: Optional[int] = None) -> bool:
    """
    Check if name exists in active documents.
    If exclude_id provided, ignore that document (for updates).
    """
```

### Error Handling

- Catch `psycopg2.Error` exceptions
- Handle `psycopg2.errors.UniqueViolation` specifically for duplicate names
- Return meaningful error messages to UI
- Log errors for debugging
- Handle connection failures gracefully

### Soft Delete Implementation

- **Create/Update**: Only operate on active documents (deleted_at IS NULL)
- **Read**: Always filter WHERE deleted_at IS NULL
- **Delete**: UPDATE documents SET deleted_at = CURRENT_TIMESTAMP WHERE id = ? AND deleted_at IS NULL
- **Restore**: Not implemented (out of scope)

## Gradio Application (`src/app.py`)

### UI Layout Specification

**Row 0: Search**
- Component: `gr.Row()`
  - `gr.Textbox(label="Search by Name", placeholder="Type to filter documents...", scale=3)`
  - `gr.Button("Clear Search", scale=1)`

**Row 1: Document Content**
- Component: `gr.Row()`
  - `gr.Textbox(label="Job Description", lines=15, placeholder="Paste job description here (avg 8192 chars)...", max_lines=20)` (scale=1)
  - `gr.Textbox(label="Resume", lines=15, placeholder="Paste resume here (avg 8192 chars)...", max_lines=20)` (scale=1)

**Row 2: Metadata**
- Component: `gr.Row()`
  - `gr.Textbox(label="Summary", lines=3, placeholder="Brief summary...")` (scale=3)
  - `gr.Textbox(label="Name", lines=1, placeholder="Unique collection name...")` (scale=1)

**Row 3: Actions**
- Component: `gr.Row()`
  - `gr.Button("Submit or Update", variant="primary")` (scale=1)
  - `gr.Button("Delete", variant="stop", interactive=False)` (scale=1)
  - `gr.Button("Clear Form", variant="secondary")` (scale=1)

**Row 4: Data Display**
- Component: `gr.Dataframe()`
  - Headers: ["ID", "Name", "Resume (preview)", "JD (preview)", "Summary", "Updated"]
  - Interactive selection enabled
  - Auto-refresh after operations
  - Resume and JD columns show first 100 characters + "..." if truncated
  - Hide created_at in display (use updated_at only)

### Display Logic for Table

Truncate resume and jd fields for table display:
```python
def truncate_text(text: str, max_length: int = 100) -> str:
    """Truncate text to max_length characters, add ellipsis if truncated."""
    if text is None:
        return ""
    text = text.strip()
    if len(text) <= max_length:
        return text
    return text[:max_length] + "..."
```

Apply truncation when preparing dataframe data:
```python
def prepare_table_data(documents):
    """
    Convert database results to display format.
    Format: (id, name, resume_preview, jd_preview, summary, updated_at)
    """
    return [
        [
            doc[0],  # id
            doc[1],  # name
            truncate_text(doc[2], 100),  # resume preview
            truncate_text(doc[3], 100),  # jd preview
            doc[4] or "",  # summary
            doc[6].strftime("%Y-%m-%d %H:%M") if doc[6] else ""  # updated_at
        ]
        for doc in documents
    ]
```

### State Management

Use `gr.State()` to track:
- `selected_row_id`: Currently selected document ID (None if no selection)
- `original_name`: Name of currently selected document (for update validation)
- Enable/disable Delete button based on selection state

### Event Handlers

**On Search Input (`search_textbox.change()`):**
```python
def on_search(search_term):
    """
    Filter documents by name (case-insensitive).
    - Query database with search_name parameter
    - Refresh dataframe with filtered results
    - Clear form selection if current selection not in results
    - Disable delete button
    """
```

**On Clear Search (`clear_search_button.click()`):**
```python
def on_clear_search():
    """
    Reset search and show all active documents.
    - Clear search textbox
    - Load all documents
    - Refresh dataframe
    """
```

**On Row Selection (`dataframe.select()`):**
```python
def on_row_select(evt: gr.SelectData, dataframe_data):
    """
    Populate form fields when a row is clicked.
    - Extract row index from evt.index
    - Get document ID from selected row
    - Fetch FULL document data from database (not truncated preview)
    - Return values to populate: jd, resume, summary, name, selected_id, original_name
    - Enable delete button
    """
```

**On Submit/Update (`submit_button.click()`):**
```python
def submit_or_update(selected_id, original_name, name, resume, jd, summary, search_term):
    """
    Create new or update existing document.
    
    Validation:
    - Name is required (non-empty after strip)
    - Name must be unique (check database)
    - If updating, allow same name if it's the original name
    
    Logic:
    - If selected_id is None: create new document
    - If selected_id exists: update existing document
    - Handle UNIQUE constraint violations gracefully
    - Refresh dataframe after operation (maintain search filter)
    - Clear form and reset selection on success
    - Show gr.Info() for success
    - Show gr.Warning() or gr.Error() for validation/operation failures
    
    Returns: Updated form state and dataframe
    """
```

**On Delete (`delete_button.click()`):**
```python
def delete_record(selected_id, search_term):
    """
    Soft delete selected document.
    
    Validation:
    - Verify selected_id is not None
    
    Logic:
    - Set deleted_at timestamp for document
    - Refresh dataframe (maintain search filter)
    - Clear form and reset selection
    - Disable delete button
    - Show gr.Info() for success
    - Show gr.Error() if operation fails
    """
```

**On Clear Form (`clear_form_button.click()`):**
```python
def clear_form():
    """
    Reset form to initial state.
    - Clear all input fields
    - Reset selected_id to None
    - Reset original_name to None
    - Disable delete button
    - Maintain current dataframe state (don't refresh)
    """
```

### Form Validation

- **Name**: 
  - Required field (non-empty after strip)
  - Must be unique across active documents
  - Check uniqueness before submit
  - Show specific error: "Name '{name}' already exists"
- **Resume, JD, Summary**: Optional but trim whitespace
- Show `gr.Info()` for success messages
- Show `gr.Warning()` for validation failures
- Show `gr.Error()` for database operation failures

### Initial State

- Load and display all active documents on startup
- All form fields empty
- Delete button disabled
- selected_row_id = None
- original_name = None
- search_term = ""

## Package Management with `uv`

### `pyproject.toml`
```toml
[project]
name = "gradio-documents-crud"
version = "0.1.0"
description = "Gradio-based CRUD application for PostgreSQL documents table"
requires-python = ">=3.10"
dependencies = [
    "gradio>=4.0.0",
    "psycopg2-binary>=2.9.9",
    "python-dotenv>=1.0.0",
]

[project.optional-dependencies]
dev = [
    "black>=23.0.0",
    "pytest>=7.0.0",
]

[tool.black]
line-length = 88
target-version = ['py310']
include = '\.pyi?$'

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

## README.md Content

Include sections for:

### 1. Prerequisites
- PostgreSQL 17 installed and running locally
- Python 3.10+ installed
- uv package manager installed (`pip install uv` or follow https://docs.astral.sh/uv/)

### 2. Database Setup
```bash
# Create database
createdb documents_db

# Run migration
psql -d documents_db -f migrations/001_create_documents_table.sql
```

### 3. Application Setup
```bash
# Clone/navigate to project directory
cd gradio-documents-crud

# Copy environment template
cp .env.example .env

# Edit .env with your PostgreSQL credentials
# nano .env  # or use your preferred editor

# Install dependencies with uv
uv sync

# Run the application
uv run python src/app.py
```

### 4. Usage Instructions

**Starting the Application:**
- Application opens at `http://localhost:7860`
- Browser should open automatically

**Creating a New Document:**
1. Fill in the Name field (required, must be unique)
2. Paste job description in "Job Description" field
3. Paste resume in "Resume" field
4. Optionally add a summary
5. Click "Submit or Update"

**Searching Documents:**
1. Type in the "Search by Name" field
2. Table updates automatically (case-insensitive partial match)
3. Click "Clear Search" to show all documents

**Editing a Document:**
1. Click on any row in the table to select it
2. Full document data loads into form fields
3. Modify any fields (Name must remain unique)
4. Click "Submit or Update" to save changes

**Deleting a Document:**
1. Click on a row in the table to select it
2. "Delete" button becomes enabled
3. Click "Delete" to soft-delete the document
4. Document is hidden from view but remains in database

**Clearing the Form:**
- Click "Clear Form" to reset all fields without saving

### 5. Key Features

- **Unique Names**: Document names must be unique (enforced by database)
- **Soft Delete**: Deleted documents are hidden but not permanently removed
- **Search**: Filter documents by name (case-insensitive)
- **Large Text Support**: Resume and JD fields support ~8KB of text
- **Auto-timestamps**: Created and updated timestamps are automatic
- **Table Preview**: Resume/JD show first 100 characters in table

### 6. Development
```bash
# Format code with black
uv run black src/

# Run tests (if implemented)
uv run pytest

# Check for formatting issues
uv run black --check src/
```

### 7. Database Management

**View Soft-Deleted Documents:**
```sql
SELECT id, name, deleted_at 
FROM documents 
WHERE deleted_at IS NOT NULL 
ORDER BY deleted_at DESC;
```

**Restore a Soft-Deleted Document:**
```sql
UPDATE documents 
SET deleted_at = NULL 
WHERE id = <document_id>;
```

**Permanently Delete (Hard Delete):**
```sql
DELETE FROM documents WHERE id = <document_id>;
```

**Purge All Soft-Deleted Documents:**
```sql
DELETE FROM documents WHERE deleted_at IS NOT NULL;
```

### 8. Troubleshooting

**Connection Errors:**
- Verify PostgreSQL is running: `pg_isready`
- Check credentials in `.env` file
- Ensure database exists: `psql -l | grep documents_db`

**Permission Errors:**
- Ensure database user has CREATE/INSERT/UPDATE/DELETE privileges
- Grant permissions: `GRANT ALL PRIVILEGES ON DATABASE documents_db TO your_username;`

**Duplicate Name Error:**
- Document names must be unique
- Check existing names: `SELECT name FROM documents WHERE deleted_at IS NULL;`
- Use search to find existing document
- Choose a different name or update the existing document

**Port Conflicts:**
- Gradio default port 7860 can be changed in `app.py`
- Modify: `demo.launch(server_port=YOUR_PORT)`

**Large Text Issues:**
- PostgreSQL TEXT type supports up to ~1GB
- 8KB average is well within limits
- If UI feels slow, check system resources

## `.gitignore`
```gitignore
# Environment variables
.env

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv/
*.egg-info/
dist/
build/

# uv
.uv/
uv.lock

# IDE
.vscode/
.idea/
*.swp
*.swo
*.sublime-project
*.sublime-workspace

# OS
.DS_Store
Thumbs.db

# Database
*.db
*.sqlite
*.sqlite3

# Logs
*.log
```

## Code Style Requirements

All Python code must:
- Follow black formatting (line length: 88)
- Use type hints for function signatures
- Include docstrings for all functions and classes
- Handle exceptions explicitly with informative error messages
- Use meaningful variable names (no single letters except in comprehensions)
- Add comments for complex logic
- Keep functions focused (single responsibility)

Example:
```python
def soft_delete_document(doc_id: int) -> Tuple[bool, str]:
    """
    Soft delete a document by setting its deleted_at timestamp.

    Args:
        doc_id: The ID of the document to soft delete

    Returns:
        Tuple of (success: bool, message: str)
        - (True, "Document deleted successfully") on success
        - (False, "Error message") on failure

    Raises:
        ValueError: If doc_id is invalid or negative
        psycopg2.Error: If database operation fails
    """
    if doc_id is None or doc_id <= 0:
        return False, "Invalid document ID"

    try:
        conn = get_connection()
        with conn.cursor() as cur:
            cur.execute(
                """
                UPDATE documents 
                SET deleted_at = CURRENT_TIMESTAMP 
                WHERE id = %s AND deleted_at IS NULL
                RETURNING id
                """,
                (doc_id,),
            )
            result = cur.fetchone()
            conn.commit()

            if result:
                return True, f"Document {doc_id} deleted successfully"
            else:
                return False, "Document not found or already deleted"

    except psycopg2.Error as e:
        conn.rollback()
        error_msg = f"Database error: {str(e)}"
        print(error_msg)  # Log for debugging
        return False, error_msg

    finally:
        if conn:
            conn.close()
```

## Testing Considerations

Manual testing checklist for README:

**Basic CRUD Operations:**
- [ ] Create new document with all fields
- [ ] Create document with only name (minimal)
- [ ] Read/display all documents in table
- [ ] Select row and verify full text loads (not truncated)
- [ ] Update document fields
- [ ] Soft delete document
- [ ] Verify deleted document disappears from table

**Uniqueness Constraint:**
- [ ] Try to create two documents with same name (should fail)
- [ ] Update document to use existing name (should fail)
- [ ] Update document keeping same name (should succeed)

**Search Functionality:**
- [ ] Search by exact name match
- [ ] Search by partial name (beginning, middle, end)
- [ ] Search is case-insensitive
- [ ] Clear search returns all documents
- [ ] Search with no results shows empty table

**UI State Management:**
- [ ] Delete button disabled when no row selected
- [ ] Delete button enabled when row selected
- [ ] Clear form resets all fields and disables delete button
- [ ] Form clears after successful create
- [ ] Form clears after successful delete
- [ ] Form maintains selection during failed update

**Data Truncation:**
- [ ] Table shows only first 100 chars of resume/JD
- [ ] Full text loads in form when row selected
- [ ] Long text (>8KB) handles properly

**Error Handling:**
- [ ] Empty name shows validation error
- [ ] Duplicate name shows specific error message
- [ ] Database connection failure shows error
- [ ] Invalid data shows appropriate error

## Security Considerations

Since this is local-only, single-user application:
- ✅ Use parameterized queries (prevent SQL injection)
- ✅ Store credentials in .env (not in code)
- ✅ Add .env to .gitignore
- ✅ Unique constraints prevent data conflicts
- ⚠️ No authentication/authorization (local use only)
- ⚠️ No input sanitization beyond SQL parameters (trusted local user)
- ⚠️ Soft-deleted data remains in database (use hard delete if sensitive)
- ⚠️ Do NOT expose to public internet without adding security layers

## Performance Considerations

Optimized for <100 documents:
- Simple indexed queries are sufficient (O(log n) lookups)
- No pagination needed
- Full table refresh acceptable (<1ms for 100 rows)
- LIKE queries for search are fast enough (partial index helps)
- Connection per request is fine (no pooling needed)
- Large text fields (8KB) are manageable

## Implementation Sequence

1. **Setup**: 
   - Create project structure
   - Initialize pyproject.toml
   - Create .env.example and .gitignore

2. **Database**:
   - Create migration file with soft delete support
   - Test database connection
   - Verify unique constraint on name

3. **Database Module (db.py)**:
   - Implement connection management
   - Implement all CRUD functions with soft delete
   - Implement search functionality
   - Add name uniqueness validation
   - Test each function independently

4. **Gradio UI (app.py)**:
   - Build layout matching specification
   - Implement state management
   - Add truncation logic for table display
   - Implement search UI components

5. **Event Handlers**:
   - Wire up search functionality
   - Wire up row selection (load full data)
   - Wire up submit/update with validation
   - Wire up soft delete
   - Wire up clear form/search

6. **Testing**:
   - Manual test all CRUD operations
   - Test unique name constraint
   - Test search functionality
   - Test soft delete behavior
   - Test form state management

7. **Documentation**:
   - Complete README with setup instructions
   - Add troubleshooting section
   - Include manual testing checklist

8. **Formatting**:
   - Run black on all Python files
   - Verify code style compliance

## Success Criteria

- ✅ PostgreSQL table created with UNIQUE constraint on name
- ✅ Soft delete implemented (deleted_at column)
- ✅ Gradio UI matches layout specification exactly
- ✅ Search by name works (case-insensitive)
- ✅ Table shows truncated resume/JD (100 chars)
- ✅ Form shows full resume/JD when row selected
- ✅ All CRUD operations work correctly
- ✅ Name uniqueness enforced with helpful error messages
- ✅ Row selection populates form fields
- ✅ Delete button only enabled when row selected
- ✅ Code passes black formatting
- ✅ README provides clear setup instructions
- ✅ .env.example template provided
- ✅ Application runs locally without errors
- ✅ All manual tests pass

## Implementation Notes

### Database Considerations
- PostgreSQL 17 supports all required features
- Soft delete pattern: deleted_at IS NULL means active
- Partial index on deleted_at improves query performance
- UNIQUE constraint on name applies across all rows (including deleted)
  - Consider: If you want to reuse deleted names, modify constraint to be partial: 
    `CREATE UNIQUE INDEX idx_documents_name_unique ON documents(name) WHERE deleted_at IS NULL;`

### UI Considerations
- Average 8KB text per field means ~200-300 lines displayed
- Gradio textbox lines=15 with max_lines=20 provides good viewing area
- Table preview at 100 chars is ~1-2 short sentences
- Search updates table in real-time (on textbox change event)

### State Management
- selected_row_id tracks which document is being edited
- original_name needed to allow name updates (same name = OK, different name = check uniqueness)
- Search term must persist through operations to maintain filter

### Edge Cases to Handle
- Selecting deleted document (won't happen - filtered from table)
- Updating to blank name (validation error)
- Network interruption during operation (database transaction rollback)
- Very long names (TEXT type handles it, UI may wrap)
- Special characters in search (parameterized query handles it)
- Concurrent access (single user, not a concern)
